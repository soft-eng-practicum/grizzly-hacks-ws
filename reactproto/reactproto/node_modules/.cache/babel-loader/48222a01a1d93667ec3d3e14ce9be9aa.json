{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _has from \"lodash/has\";\nimport _keys from \"lodash/keys\";\nimport _forEach from \"lodash/forEach\";\nimport _filter from \"lodash/filter\";\nimport _keyBy from \"lodash/keyBy\";\nimport { Children, isValidElement } from 'react';\n/**\r\n * Given `this.props.children`, return an object mapping key to child.\r\n *\r\n * @param {object} children Element's children\r\n * @return {object} Mapping of key to child\r\n */\n\nexport var getChildMapping = function getChildMapping(children) {\n  return _keyBy(_filter(Children.toArray(children), isValidElement), 'key');\n};\n\nvar getPendingKeys = function getPendingKeys(prev, next) {\n  var nextKeysPending = {};\n  var pendingKeys = [];\n\n  _forEach(_keys(prev), function (prevKey) {\n    if (!_has(next, prevKey)) {\n      pendingKeys.push(prevKey);\n      return;\n    }\n\n    if (pendingKeys.length) {\n      nextKeysPending[prevKey] = pendingKeys;\n      pendingKeys = [];\n    }\n  });\n\n  return [nextKeysPending, pendingKeys];\n};\n\nvar getValue = function getValue(key, prev, next) {\n  return _has(next, key) ? next[key] : prev[key];\n};\n/**\r\n * When you're adding or removing children some may be added or removed in the same render pass. We want to show *both*\r\n * since we want to simultaneously animate elements in and out. This function takes a previous set of keys and a new set\r\n * of keys and merges them with its best guess of the correct ordering.\r\n *\r\n * @param {object} prev Prev children as returned from `getChildMapping()`\r\n * @param {object} next Next children as returned from `getChildMapping()`\r\n * @return {object} A key set that contains all keys in `prev` and all keys in `next` in a reasonable order\r\n */\n\n\nexport var mergeChildMappings = function mergeChildMappings() {\n  var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var childMapping = {};\n\n  var _getPendingKeys = getPendingKeys(prev, next),\n      _getPendingKeys2 = _slicedToArray(_getPendingKeys, 2),\n      nextKeysPending = _getPendingKeys2[0],\n      pendingKeys = _getPendingKeys2[1];\n\n  _forEach(_keys(next), function (nextKey) {\n    if (_has(nextKeysPending, nextKey)) {\n      _forEach(nextKeysPending[nextKey], function (pendingKey) {\n        childMapping[pendingKey] = getValue(pendingKey, prev, next);\n      });\n    }\n\n    childMapping[nextKey] = getValue(nextKey, prev, next);\n  });\n\n  _forEach(pendingKeys, function (pendingKey) {\n    childMapping[pendingKey] = getValue(pendingKey, prev, next);\n  });\n\n  return childMapping;\n};","map":{"version":3,"sources":["C:/Users/josiah/OneDrive/Documents/SoftDevII/grizzly-hacks-ws/reactproto/node_modules/semantic-ui-react/dist/es/lib/childMapping.js"],"names":["_slicedToArray","_has","_keys","_forEach","_filter","_keyBy","Children","isValidElement","getChildMapping","children","toArray","getPendingKeys","prev","next","nextKeysPending","pendingKeys","prevKey","push","length","getValue","key","mergeChildMappings","arguments","undefined","childMapping","_getPendingKeys","_getPendingKeys2","nextKey","pendingKey"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\r\nimport _has from \"lodash/has\";\r\nimport _keys from \"lodash/keys\";\r\nimport _forEach from \"lodash/forEach\";\r\nimport _filter from \"lodash/filter\";\r\nimport _keyBy from \"lodash/keyBy\";\r\nimport { Children, isValidElement } from 'react';\r\n/**\r\n * Given `this.props.children`, return an object mapping key to child.\r\n *\r\n * @param {object} children Element's children\r\n * @return {object} Mapping of key to child\r\n */\r\n\r\nexport var getChildMapping = function getChildMapping(children) {\r\n  return _keyBy(_filter(Children.toArray(children), isValidElement), 'key');\r\n};\r\n\r\nvar getPendingKeys = function getPendingKeys(prev, next) {\r\n  var nextKeysPending = {};\r\n  var pendingKeys = [];\r\n\r\n  _forEach(_keys(prev), function (prevKey) {\r\n    if (!_has(next, prevKey)) {\r\n      pendingKeys.push(prevKey);\r\n      return;\r\n    }\r\n\r\n    if (pendingKeys.length) {\r\n      nextKeysPending[prevKey] = pendingKeys;\r\n      pendingKeys = [];\r\n    }\r\n  });\r\n\r\n  return [nextKeysPending, pendingKeys];\r\n};\r\n\r\nvar getValue = function getValue(key, prev, next) {\r\n  return _has(next, key) ? next[key] : prev[key];\r\n};\r\n/**\r\n * When you're adding or removing children some may be added or removed in the same render pass. We want to show *both*\r\n * since we want to simultaneously animate elements in and out. This function takes a previous set of keys and a new set\r\n * of keys and merges them with its best guess of the correct ordering.\r\n *\r\n * @param {object} prev Prev children as returned from `getChildMapping()`\r\n * @param {object} next Next children as returned from `getChildMapping()`\r\n * @return {object} A key set that contains all keys in `prev` and all keys in `next` in a reasonable order\r\n */\r\n\r\n\r\nexport var mergeChildMappings = function mergeChildMappings() {\r\n  var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  var childMapping = {};\r\n\r\n  var _getPendingKeys = getPendingKeys(prev, next),\r\n      _getPendingKeys2 = _slicedToArray(_getPendingKeys, 2),\r\n      nextKeysPending = _getPendingKeys2[0],\r\n      pendingKeys = _getPendingKeys2[1];\r\n\r\n  _forEach(_keys(next), function (nextKey) {\r\n    if (_has(nextKeysPending, nextKey)) {\r\n      _forEach(nextKeysPending[nextKey], function (pendingKey) {\r\n        childMapping[pendingKey] = getValue(pendingKey, prev, next);\r\n      });\r\n    }\r\n\r\n    childMapping[nextKey] = getValue(nextKey, prev, next);\r\n  });\r\n\r\n  _forEach(pendingKeys, function (pendingKey) {\r\n    childMapping[pendingKey] = getValue(pendingKey, prev, next);\r\n  });\r\n\r\n  return childMapping;\r\n};"]},"metadata":{},"sourceType":"module"}